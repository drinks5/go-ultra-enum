package parser

const Header = `// Code generated by go-ultra-enum; DO NOT EDIT.
	package {{.Name}}
    import (
        "fmt"
    	"encoding/json"
    )
`
const Tpl = `type {{.NewName | LcFirst}}Enum struct{
{{ range $e := .Elements}}
{{$e.Name}} {{$.NewName }}Ele{{ end}}
}
func (x *{{.NewName | LcFirst}}Enum)Names() []string{
    return []string{
        {{- range $e := .Elements}}
            "{{.Name}}",
        {{- end}}
    }
}
func (x *{{.NewName | LcFirst}}Enum)Values() []{{.Tpe}}{
    return []{{.Tpe}}{
        {{- range $e := .Elements}}
            {{if eq .Tpe "string"}}"{{.Value}}"{{else}}{{.Value}}{{end}},
        {{- end}}
    }
}
func (x *{{.NewName | LcFirst}}Enum)UnMarshalName(name string) (*{{.NewName }}Ele, error){
	if val, ok := {{.NewName | LcFirst}}EnumNameMap[name]; ok{
		return val, nil
	}
	return nil, fmt.Errorf("%s does not belong to names", name)
}
func (x *{{.NewName | LcFirst}}Enum)UnMarshalValue(value {{.Tpe}}) (*{{.NewName }}Ele, error){
	if val, ok := {{.NewName | LcFirst}}EnumValueMap[value]; ok{
		return val, nil
	}
	return nil, fmt.Errorf("%v does not belong to values", value)
}

type {{.NewName }}Ele struct {
    Name string
    Value {{.Tpe}}
    Description string
}
func (x *{{.NewName }}Ele) MarshalJson() ([]byte, error) {
    return json.Marshal(x)
}


var (
    {{.NewName}} = {{.NewName | LcFirst }}Enum{
        {{- range $e := .Elements}}
            {{.Name}} : {{$.NewName }}Ele{Name: "{{.Name}}", Value: {{if eq .Tpe "string"}}"{{.Value}}"{{else}}{{.Value}}{{end}}, Description: "{{.Description}}"},
        {{- end}}
    }
    {{.NewName | LcFirst}}EnumNameMap = map[string]*{{.NewName }}Ele{
        {{- range $e := .Elements}}
            "{{.Name}}": &{{$.NewName}}.{{.Name}},
        {{- end}}
    }
    {{.NewName | LcFirst}}EnumValueMap = map[{{.Tpe}}]*{{.NewName }}Ele{
        {{- range $e := .Elements}}
            {{if eq .Tpe "string"}}"{{.Value}}"{{else}}{{.Value}}{{end}}: &{{$.NewName}}.{{.Name}},
        {{- end}}
    }
)
`
